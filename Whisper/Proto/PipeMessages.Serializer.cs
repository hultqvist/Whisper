//
//	This is the backend code for reading and writing
//	Report bugs to: https://silentorbit.com/protobuf/
//
//	Generated by ProtocolBuffer
//	- a pure c# code generation implementation of protocol buffers
//

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using ProtocolBuffers;
namespace Whisper.Chunks
{
	public partial class ChunkKeys
	{
		public static ChunkKeys Deserialize(Stream stream)
		{
			ChunkKeys instance = new ChunkKeys();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static ChunkKeys Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Chunks.ChunkKeys, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Chunks.ChunkKeys, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Chunks.ChunkKeys instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Chunks.ChunkKeys Deserialize(Stream stream, Whisper.Chunks.ChunkKeys instance)
		{
			if(instance.EncryptedKeys == null)
				instance.EncryptedKeys = new List<byte[]>();
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 10: //Field 1 LengthDelimited
							instance.Iv = ProtocolParser.ReadBytes(stream);
							break;
						case 18: //Field 2 LengthDelimited
							instance.EncryptedKeys.Add(ProtocolParser.ReadBytes(stream));
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Chunks.ChunkKeys Read(byte[] buffer, Whisper.Chunks.ChunkKeys instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, ChunkKeys instance)
		{
			if(instance.Iv == null)
				throw new ArgumentNullException("Iv", "Required by proto specification.");
			ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.LengthDelimited));
			ProtocolParser.WriteBytes(stream, instance.Iv);
			if(instance.EncryptedKeys != null)
			{
				foreach(byte[] i2 in instance.EncryptedKeys)
				{
					ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(2, Wire.LengthDelimited));
					ProtocolParser.WriteBytes(stream, i2);
			
				}
			}
		}
		
		public static byte[] SerializeToBytes(ChunkKeys instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class PipeHeader
	{
		public static PipeHeader Deserialize(Stream stream)
		{
			PipeHeader instance = new PipeHeader();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static PipeHeader Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.PipeHeader, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.PipeHeader, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.PipeHeader instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.PipeHeader Deserialize(Stream stream, Whisper.Storing.Pipe.PipeHeader instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 8: //Field 1 Varint
							instance.TypeID = ProtocolParser.ReadUInt32(stream);
							break;
						case 16: //Field 2 Varint
							instance.DebugNumber = ProtocolParser.ReadUInt32(stream);
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.PipeHeader Read(byte[] buffer, Whisper.Storing.Pipe.PipeHeader instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, PipeHeader instance)
		{
			ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.Varint));
			ProtocolParser.WriteUInt32(stream, instance.TypeID);
			ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(2, Wire.Varint));
			ProtocolParser.WriteUInt32(stream, instance.DebugNumber);
		}
		
		public static byte[] SerializeToBytes(PipeHeader instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class RequestCustomHash
	{
		public static RequestCustomHash Deserialize(Stream stream)
		{
			RequestCustomHash instance = new RequestCustomHash();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static RequestCustomHash Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.RequestCustomHash, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.RequestCustomHash, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.RequestCustomHash instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestCustomHash Deserialize(Stream stream, Whisper.Storing.Pipe.RequestCustomHash instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 10: //Field 1 LengthDelimited
							instance.CustomID = ProtocolParser.ReadBytes(stream);
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.RequestCustomHash Read(byte[] buffer, Whisper.Storing.Pipe.RequestCustomHash instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, RequestCustomHash instance)
		{
			if(instance.CustomID == null)
				throw new ArgumentNullException("CustomID", "Required by proto specification.");
			ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.LengthDelimited));
			ProtocolParser.WriteBytes(stream, instance.CustomID);
		}
		
		public static byte[] SerializeToBytes(RequestCustomHash instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class ReplyCustomHash
	{
		public static ReplyCustomHash Deserialize(Stream stream)
		{
			ReplyCustomHash instance = new ReplyCustomHash();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static ReplyCustomHash Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.ReplyCustomHash, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.ReplyCustomHash, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.ReplyCustomHash instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyCustomHash Deserialize(Stream stream, Whisper.Storing.Pipe.ReplyCustomHash instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 10: //Field 1 LengthDelimited
							instance.ChunkHash = ProtocolParser.ReadBytes(stream);
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.ReplyCustomHash Read(byte[] buffer, Whisper.Storing.Pipe.ReplyCustomHash instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, ReplyCustomHash instance)
		{
			if(instance.ChunkHash != null)
			{
				ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.LengthDelimited));
				ProtocolParser.WriteBytes(stream, instance.ChunkHash);
			}
		}
		
		public static byte[] SerializeToBytes(ReplyCustomHash instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class RequestReadChunk
	{
		public static RequestReadChunk Deserialize(Stream stream)
		{
			RequestReadChunk instance = new RequestReadChunk();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static RequestReadChunk Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.RequestReadChunk, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.RequestReadChunk, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.RequestReadChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestReadChunk Deserialize(Stream stream, Whisper.Storing.Pipe.RequestReadChunk instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 10: //Field 1 LengthDelimited
							instance.ChunkHash = ProtocolParser.ReadBytes(stream);
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.RequestReadChunk Read(byte[] buffer, Whisper.Storing.Pipe.RequestReadChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, RequestReadChunk instance)
		{
			if(instance.ChunkHash == null)
				throw new ArgumentNullException("ChunkHash", "Required by proto specification.");
			ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.LengthDelimited));
			ProtocolParser.WriteBytes(stream, instance.ChunkHash);
		}
		
		public static byte[] SerializeToBytes(RequestReadChunk instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class ReplyReadChunk
	{
		public static ReplyReadChunk Deserialize(Stream stream)
		{
			ReplyReadChunk instance = new ReplyReadChunk();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static ReplyReadChunk Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.ReplyReadChunk, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.ReplyReadChunk, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.ReplyReadChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyReadChunk Deserialize(Stream stream, Whisper.Storing.Pipe.ReplyReadChunk instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 10: //Field 1 LengthDelimited
							instance.ChunkData = ProtocolParser.ReadBytes(stream);
							break;
						case 18: //Field 2 LengthDelimited
							if(instance.Keys == null)
								instance.Keys = Whisper.Chunks.ChunkKeys.Deserialize(ProtocolParser.ReadBytes(stream));
							else
								instance.Keys = Serializer.Read(ProtocolParser.ReadBytes(stream), instance.Keys);
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.ReplyReadChunk Read(byte[] buffer, Whisper.Storing.Pipe.ReplyReadChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, ReplyReadChunk instance)
		{
			if(instance.ChunkData != null)
			{
				ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.LengthDelimited));
				ProtocolParser.WriteBytes(stream, instance.ChunkData);
			}
			if(instance.Keys != null)
			{
				ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(2, Wire.LengthDelimited));
				using(MemoryStream ms2 = new MemoryStream())
				{
					Whisper.Chunks.ChunkKeys.Serialize(ms2, instance.Keys);
					ProtocolParser.WriteBytes(stream, ms2.ToArray());
				}
			}
		}
		
		public static byte[] SerializeToBytes(ReplyReadChunk instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class RequestWriteChunk
	{
		public static RequestWriteChunk Deserialize(Stream stream)
		{
			RequestWriteChunk instance = new RequestWriteChunk();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static RequestWriteChunk Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.RequestWriteChunk, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.RequestWriteChunk, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.RequestWriteChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestWriteChunk Deserialize(Stream stream, Whisper.Storing.Pipe.RequestWriteChunk instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 10: //Field 1 LengthDelimited
							instance.ChunkData = ProtocolParser.ReadBytes(stream);
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.RequestWriteChunk Read(byte[] buffer, Whisper.Storing.Pipe.RequestWriteChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, RequestWriteChunk instance)
		{
			if(instance.ChunkData == null)
				throw new ArgumentNullException("ChunkData", "Required by proto specification.");
			ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.LengthDelimited));
			ProtocolParser.WriteBytes(stream, instance.ChunkData);
		}
		
		public static byte[] SerializeToBytes(RequestWriteChunk instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class ReplyWriteChunk
	{
		public static ReplyWriteChunk Deserialize(Stream stream)
		{
			ReplyWriteChunk instance = new ReplyWriteChunk();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static ReplyWriteChunk Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.ReplyWriteChunk, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.ReplyWriteChunk, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.ReplyWriteChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyWriteChunk Deserialize(Stream stream, Whisper.Storing.Pipe.ReplyWriteChunk instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.ReplyWriteChunk Read(byte[] buffer, Whisper.Storing.Pipe.ReplyWriteChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, ReplyWriteChunk instance)
		{
		}
		
		public static byte[] SerializeToBytes(ReplyWriteChunk instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class RequestMessageList
	{
		public static RequestMessageList Deserialize(Stream stream)
		{
			RequestMessageList instance = new RequestMessageList();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static RequestMessageList Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.RequestMessageList, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.RequestMessageList, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.RequestMessageList instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestMessageList Deserialize(Stream stream, Whisper.Storing.Pipe.RequestMessageList instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.RequestMessageList Read(byte[] buffer, Whisper.Storing.Pipe.RequestMessageList instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, RequestMessageList instance)
		{
		}
		
		public static byte[] SerializeToBytes(RequestMessageList instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class ReplyMessageList
	{
		public static ReplyMessageList Deserialize(Stream stream)
		{
			ReplyMessageList instance = new ReplyMessageList();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static ReplyMessageList Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.ReplyMessageList, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.ReplyMessageList, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.ReplyMessageList instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyMessageList Deserialize(Stream stream, Whisper.Storing.Pipe.ReplyMessageList instance)
		{
			if(instance.ChunkHash == null)
				instance.ChunkHash = new List<byte[]>();
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 10: //Field 1 LengthDelimited
							instance.ChunkHash.Add(ProtocolParser.ReadBytes(stream));
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.ReplyMessageList Read(byte[] buffer, Whisper.Storing.Pipe.ReplyMessageList instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, ReplyMessageList instance)
		{
			if(instance.ChunkHash != null)
			{
				foreach(byte[] i1 in instance.ChunkHash)
				{
					ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.LengthDelimited));
					ProtocolParser.WriteBytes(stream, i1);
			
				}
			}
		}
		
		public static byte[] SerializeToBytes(ReplyMessageList instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class RequestStoreMessage
	{
		public static RequestStoreMessage Deserialize(Stream stream)
		{
			RequestStoreMessage instance = new RequestStoreMessage();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static RequestStoreMessage Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.RequestStoreMessage, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.RequestStoreMessage, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.RequestStoreMessage instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestStoreMessage Deserialize(Stream stream, Whisper.Storing.Pipe.RequestStoreMessage instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						case 10: //Field 1 LengthDelimited
							instance.ChunkHash = ProtocolParser.ReadBytes(stream);
							break;
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.RequestStoreMessage Read(byte[] buffer, Whisper.Storing.Pipe.RequestStoreMessage instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, RequestStoreMessage instance)
		{
			if(instance.ChunkHash == null)
				throw new ArgumentNullException("ChunkHash", "Required by proto specification.");
			ProtocolParser.WriteKey(stream, new ProtocolBuffers.Key(1, Wire.LengthDelimited));
			ProtocolParser.WriteBytes(stream, instance.ChunkHash);
		}
		
		public static byte[] SerializeToBytes(RequestStoreMessage instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}
namespace Whisper.Storing.Pipe
{
	public partial class ReplyStoreMessage
	{
		public static ReplyStoreMessage Deserialize(Stream stream)
		{
			ReplyStoreMessage instance = new ReplyStoreMessage();
			Deserialize(stream, instance);
			return instance;
		}
		
		public static ReplyStoreMessage Deserialize(byte[] buffer)
		{
			using(MemoryStream ms = new MemoryStream(buffer))
				return Deserialize(ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Storing.Pipe.ReplyStoreMessage, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Storing.Pipe.ReplyStoreMessage, new()
		{
			T instance = new T ();
			Deserialize(buffer, instance);
			return instance;
		}
		
		public static void Deserialize (byte[] buffer, Whisper.Storing.Pipe.ReplyStoreMessage instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyStoreMessage Deserialize(Stream stream, Whisper.Storing.Pipe.ReplyStoreMessage instance)
		{
			while (true)
			{
				ProtocolBuffers.Key key = null;
				try {
						//Optimize reading keys for short field numbers
						int keyByte = stream.ReadByte ();
						if (keyByte == -1)
							break;
						//Optimized reading of known fields with field ID < 16
						switch (keyByte) {
						default:
							key = ProtocolParser.ReadKey ((byte)keyByte, stream);
							break;
						}
				} catch (IOException) {
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey(stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Storing.Pipe.ReplyStoreMessage Read(byte[] buffer, Whisper.Storing.Pipe.ReplyStoreMessage instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize(Stream stream, ReplyStoreMessage instance)
		{
		}
		
		public static byte[] SerializeToBytes(ReplyStoreMessage instance)
		{
			using(MemoryStream ms = new MemoryStream())
			{
				Serialize(ms, instance);
				return ms.ToArray();
			}
		}
	}
	

}

namespace ProtocolBuffers
{
	public static partial class Serializer
	{
		
		public static Whisper.Chunks.ChunkKeys Read (Stream stream, Whisper.Chunks.ChunkKeys instance)
		{
			return Whisper.Chunks.ChunkKeys.Deserialize(stream, instance);
		}
		
		public static Whisper.Chunks.ChunkKeys Read(byte[] buffer, Whisper.Chunks.ChunkKeys instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Chunks.ChunkKeys.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Chunks.ChunkKeys instance)
		{
			Whisper.Chunks.ChunkKeys.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.PipeHeader Read (Stream stream, Whisper.Storing.Pipe.PipeHeader instance)
		{
			return Whisper.Storing.Pipe.PipeHeader.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.PipeHeader Read(byte[] buffer, Whisper.Storing.Pipe.PipeHeader instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.PipeHeader.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.PipeHeader instance)
		{
			Whisper.Storing.Pipe.PipeHeader.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.RequestCustomHash Read (Stream stream, Whisper.Storing.Pipe.RequestCustomHash instance)
		{
			return Whisper.Storing.Pipe.RequestCustomHash.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestCustomHash Read(byte[] buffer, Whisper.Storing.Pipe.RequestCustomHash instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.RequestCustomHash.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.RequestCustomHash instance)
		{
			Whisper.Storing.Pipe.RequestCustomHash.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.ReplyCustomHash Read (Stream stream, Whisper.Storing.Pipe.ReplyCustomHash instance)
		{
			return Whisper.Storing.Pipe.ReplyCustomHash.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyCustomHash Read(byte[] buffer, Whisper.Storing.Pipe.ReplyCustomHash instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.ReplyCustomHash.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.ReplyCustomHash instance)
		{
			Whisper.Storing.Pipe.ReplyCustomHash.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.RequestReadChunk Read (Stream stream, Whisper.Storing.Pipe.RequestReadChunk instance)
		{
			return Whisper.Storing.Pipe.RequestReadChunk.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestReadChunk Read(byte[] buffer, Whisper.Storing.Pipe.RequestReadChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.RequestReadChunk.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.RequestReadChunk instance)
		{
			Whisper.Storing.Pipe.RequestReadChunk.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.ReplyReadChunk Read (Stream stream, Whisper.Storing.Pipe.ReplyReadChunk instance)
		{
			return Whisper.Storing.Pipe.ReplyReadChunk.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyReadChunk Read(byte[] buffer, Whisper.Storing.Pipe.ReplyReadChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.ReplyReadChunk.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.ReplyReadChunk instance)
		{
			Whisper.Storing.Pipe.ReplyReadChunk.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.RequestWriteChunk Read (Stream stream, Whisper.Storing.Pipe.RequestWriteChunk instance)
		{
			return Whisper.Storing.Pipe.RequestWriteChunk.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestWriteChunk Read(byte[] buffer, Whisper.Storing.Pipe.RequestWriteChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.RequestWriteChunk.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.RequestWriteChunk instance)
		{
			Whisper.Storing.Pipe.RequestWriteChunk.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.ReplyWriteChunk Read (Stream stream, Whisper.Storing.Pipe.ReplyWriteChunk instance)
		{
			return Whisper.Storing.Pipe.ReplyWriteChunk.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyWriteChunk Read(byte[] buffer, Whisper.Storing.Pipe.ReplyWriteChunk instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.ReplyWriteChunk.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.ReplyWriteChunk instance)
		{
			Whisper.Storing.Pipe.ReplyWriteChunk.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.RequestMessageList Read (Stream stream, Whisper.Storing.Pipe.RequestMessageList instance)
		{
			return Whisper.Storing.Pipe.RequestMessageList.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestMessageList Read(byte[] buffer, Whisper.Storing.Pipe.RequestMessageList instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.RequestMessageList.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.RequestMessageList instance)
		{
			Whisper.Storing.Pipe.RequestMessageList.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.ReplyMessageList Read (Stream stream, Whisper.Storing.Pipe.ReplyMessageList instance)
		{
			return Whisper.Storing.Pipe.ReplyMessageList.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyMessageList Read(byte[] buffer, Whisper.Storing.Pipe.ReplyMessageList instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.ReplyMessageList.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.ReplyMessageList instance)
		{
			Whisper.Storing.Pipe.ReplyMessageList.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.RequestStoreMessage Read (Stream stream, Whisper.Storing.Pipe.RequestStoreMessage instance)
		{
			return Whisper.Storing.Pipe.RequestStoreMessage.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.RequestStoreMessage Read(byte[] buffer, Whisper.Storing.Pipe.RequestStoreMessage instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.RequestStoreMessage.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.RequestStoreMessage instance)
		{
			Whisper.Storing.Pipe.RequestStoreMessage.Serialize(stream, instance);
		}
		

		
		public static Whisper.Storing.Pipe.ReplyStoreMessage Read (Stream stream, Whisper.Storing.Pipe.ReplyStoreMessage instance)
		{
			return Whisper.Storing.Pipe.ReplyStoreMessage.Deserialize(stream, instance);
		}
		
		public static Whisper.Storing.Pipe.ReplyStoreMessage Read(byte[] buffer, Whisper.Storing.Pipe.ReplyStoreMessage instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Storing.Pipe.ReplyStoreMessage.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write(Stream stream, Whisper.Storing.Pipe.ReplyStoreMessage instance)
		{
			Whisper.Storing.Pipe.ReplyStoreMessage.Serialize(stream, instance);
		}
		


	}
}
