//
//	This is the backend code for reading and writing
//	Report bugs to: https://silentorbit.com/protobuf/
//
//	Generated by ProtocolBuffer
//	- a pure c# code generation implementation of protocol buffers
//
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using ProtocolBuffers;

namespace Whisper.Encryption
{
	public partial class KeysHeader
	{
		public static KeysHeader Deserialize (Stream stream)
		{
			KeysHeader instance = new KeysHeader ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static KeysHeader Deserialize (byte[] buffer)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				return Deserialize (ms);
		}
		
		public static T Deserialize<T> (Stream stream) where T : Whisper.Encryption.KeysHeader, new()
		{
			T instance = new T ();
			Deserialize (stream, instance);
			return instance;
		}
		
		public static T Deserialize<T> (byte[] buffer) where T : Whisper.Encryption.KeysHeader, new()
		{
			T instance = new T ();
			Deserialize (buffer, instance);
			return instance;
		}
		
		public static Whisper.Encryption.KeysHeader Deserialize (byte[] buffer, Whisper.Encryption.KeysHeader instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
		
		public static Whisper.Encryption.KeysHeader Deserialize (Stream stream, Whisper.Encryption.KeysHeader instance)
		{
			if (instance.EncryptedKeys == null)
				instance.EncryptedKeys = new List<byte[]> ();
			while (true) {
				ProtocolBuffers.Key key = null;
				int keyByte = stream.ReadByte ();
				if (keyByte == -1)
					break;
				//Optimized reading of known fields with field ID < 16
				switch (keyByte) {
				case 10: //Field 1 LengthDelimited
					instance.IV = ProtocolParser.ReadBytes (stream);
					break;
				case 18: //Field 2 LengthDelimited
					instance.EncryptedKeys.Add (ProtocolParser.ReadBytes (stream));
		
					break;
				default:
					key = ProtocolParser.ReadKey ((byte)keyByte, stream);
					break;
				}
		
				if (key == null)
					continue;
		
				//Reading field ID > 16 and unknown field ID/wire type combinations
				switch (key.Field) {
				case 0:
					throw new InvalidDataException ("Invalid field id: 0, something went wrong in the stream");
				default:
					ProtocolParser.SkipKey (stream, key);
					break;
				}
			}
			
			return instance;
		}
		
		public static Whisper.Encryption.KeysHeader Read (byte[] buffer, Whisper.Encryption.KeysHeader instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Deserialize (ms, instance);
			return instance;
		}
	
		public static void Serialize (Stream stream, KeysHeader instance)
		{
			if (instance.IV == null)
				throw new ArgumentNullException ("IV", "Required by proto specification.");
			ProtocolParser.WriteKey (stream, new ProtocolBuffers.Key (1, Wire.LengthDelimited));
			ProtocolParser.WriteBytes (stream, instance.IV);
			if (instance.EncryptedKeys != null) {
				foreach (byte[] i2 in instance.EncryptedKeys) {
					ProtocolParser.WriteKey (stream, new ProtocolBuffers.Key (2, Wire.LengthDelimited));
					ProtocolParser.WriteBytes (stream, i2);
			
				}
			}
		}
		
		public static byte[] SerializeToBytes (KeysHeader instance)
		{
			using (MemoryStream ms = new MemoryStream()) {
				Serialize (ms, instance);
				return ms.ToArray ();
			}
		}
	}
	

}

namespace ProtocolBuffers
{
	public static partial class Serializer
	{
		public static Whisper.Encryption.KeysHeader Read (Stream stream, Whisper.Encryption.KeysHeader instance)
		{
			return Whisper.Encryption.KeysHeader.Deserialize (stream, instance);
		}
		
		public static Whisper.Encryption.KeysHeader Read (byte[] buffer, Whisper.Encryption.KeysHeader instance)
		{
			using (MemoryStream ms = new MemoryStream(buffer))
				Whisper.Encryption.KeysHeader.Deserialize (ms, instance);
			return instance;
		}
		
		public static void Write (Stream stream, Whisper.Encryption.KeysHeader instance)
		{
			Whisper.Encryption.KeysHeader.Serialize (stream, instance);
		}


	}
}
